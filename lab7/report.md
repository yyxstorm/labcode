# 操作系统Lab7实验报告

2012011289
计22
姚宇轩

## 重要知识点及关系
进程状态转移模型，对应代码中的wait.[ch]中的队列，应用在信号灯中
信号灯机制，对应sem.[ch]中的定义，在check_sync.c中用它实现了哲学家就餐问题的第一种解法
以信号灯机制为基础的管程机制，对应monitor.[ch]中的定义，在check_sync.c中用它实现了哲学家就餐问题的第二种解法
临界区和互斥锁的概念，在实验中由信号灯实现


## 练习0：填写已有实验
用meld。注意trap.c中trap_dispatch函数中的时钟中断函数调用要更新为run_timer_list();。

## 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题
用一个信号灯变量mutex保证对共享变量state_sema写的互斥性，每个哲学家有一个信号灯表示自己请求的叉子是否可用。如果想拿起叉子但拿不到则睡在这个信号灯上，当被唤醒并获得cpu时叉子已可使用，便开始就餐；放下叉子时尝试唤醒两边的哲学家进行就餐。

### 请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。
信号灯的基础是一个表示空闲的资源使用权数量的数字和表示等待资源使用权的进程队列，基本操作是请求使用权的P操作和释放使用权的V操作。P操作基本过程是：如果有使用权剩余，则获得之（修改计数）并返回继续执行，否则进程进入该信号灯的等待队列并调用schedule交出cpu，直到被其他进程唤醒时进入就绪队列，获得cpu使用权时从schedule后开始，离开等待队列并继续操作。V操作的基本过程是：如果等待队列不为空则唤醒队列中第一个等待进程，放入就绪队列，否则空闲资源计数加一即可。

### 请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。
用户态实现的主要问题是没有权限，不能直接操作进程状态、进行进程切换和调度，无法使用特权指令如cli。解决也不难，把信号灯机制用系统调用包装起来提供给用户即可。更复杂一点的解决方案是写一个用户态的库实现信号灯机制，在权限不够的地方则使用系统调用完成，也就是说把现在的信号灯相关代码写到用户库里，其中需要特殊权限的操作改为系统调用。

## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题
此处用管程解决了哲学家就餐问题，管程的基本运行机制见下文。管程管理的数据只有state_condvar，各个哲学家的请求通过管程互斥化，每个哲学家有一个管程中的条件变量表示他所请求的叉子目前是否就绪。和上一种实现的区别其实只是把mutex和信号灯列表以管程的mutex和条件变量列表的形式重新表达了一遍而已，运行机制也是，不再赘述。

### 请在实验报告中给出内核级条件变量的设计描述，并说其大致执行流流程。
条件变量主体是一个信号灯，含有等待该条件变量为真的进程列表，是管程机制的一部分。管程是各个进程访问某数据的通用接口，由于它同一时刻只受理一个进程的请求，因此完成了对数据的互斥共享。单纯的管程是不可用的，因为如果占用管程的进程等待某条件，而该条件需要其他进程进入管程才能改变则会发生二者的死锁。为解决这一问题引入了条件变量，让等待某条件的进程进入睡眠释放管程使用权，在条件满足时被唤醒。因此管程机制中有四种进程：等待进入管程的进程（mutex等待列表），正在占用管程的进程，已进入管程但是因为等待某个条件变量而在沉睡的进程（某个cv的等待列表），已进入管程但是在运行中因为唤醒其他进程而交出了管程占用权（管程只受理一个进程的请求的限制）进入沉睡的进程（next等待列表）。管程机制基本就是在这四种状态之间的转换：触发条件变量（cond_signal）时如该条件变量有进程等待则唤醒他而自己进入next沉睡；
等待条件变量（cond_wait）时唤醒next或mutex列表中的某个进程而自己进入该cv沉睡。

### 请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。
和上述用户态信号灯机制一样。

### 我的设计实现过程
搞清楚上述管程的概念和运行过程，monitor结构体和condvar结构体各变量的定义，结合注释设计实现管程机制并不难。

### 和标准答案的差别
都是从注释来的，差别不大，有以下几条：
1.phi_take_forks_condvar函数中用不着while循环，一个if就够了。因为cond_wait后如果被唤醒则必然处于EATING状态，不用再测试一遍。
2.前置++和--改成后置，提高一点效率。
3.按照概念，down函数是沉睡的主体，对沉睡列表的计数应紧密围绕在它旁边，因此代码顺序不同。
4.写了一点新的输出，会更清楚一些。
